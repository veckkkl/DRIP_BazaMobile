## Отличия Swift и Kotlin при выполнении задания

В процессе выполнения задания были реализованы две версии консольного приложения — на Swift и на Kotlin. Оба языка позволили реализовать одинаковую логику, однако при разработке выявились различия в подходах, синтаксисе и уровне удобства.

### 1. Работа с дженериками
В Swift используются строгие ограничения для дженериков с помощью конструкции `where T: Protocol`. Компилятор требует явного указания типов и ограничений, что делает код более безопасным, но несколько увеличивает его объем.  
В Kotlin дженерики описываются проще — через `class <T: Interface>`. Код выглядит короче, но проверки типов выполняются менее строго.  
В целом, Swift обеспечивает большую безопасность, а Kotlin — более лаконичный синтаксис.

### 2. Работа с опциональными типами и null-безопасностью
Swift использует систему опционалов (`Optional`), которая вынуждает программиста явно проверять значения перед использованием. Это уменьшает вероятность ошибок, связанных с `nil`. Для реализации безопасного ввода использовался `enum Input<T>`, что позволило элегантно обрабатывать отмену операций.  
В Kotlin аналогичная задача решается через nullable-типы (`T?`) и операторы `?.` и `?:`. В нашем проекте была использована конструкция `sealed class Input<T>`, которая по смыслу совпадает со Swift-реализацией, но требует меньше кода.  
Swift оказался строже в проверках, Kotlin — гибче и короче.

### 3. Работа с датами
В Swift применялся класс `DateFormatter` и собственный протокол `DateFormatting`. Форматирование даты выполнялось явно, с заданием шаблона.  
В Kotlin использовался `java.time.format.DateTimeFormatter`, который поддерживает часовые пояса и локали по умолчанию. Он оказался удобнее при форматировании времени, особенно для разных регионов.

### 4. Архитектура и протоколы
Swift активно использует протоколы для описания контрактов и поведения (`CanvasUnit`, `Note`, `Notebook`, `Storage`). Это позволило построить архитектуру, близкую к объектно-ориентированным принципам, с чётким разделением ответственности.  
В Kotlin используются интерфейсы и открытые классы (`interface`, `open class`). Подход схож, но требует меньше явных описаний.  
В целом, архитектура Swift получилась немного строже и чище, а Kotlin — проще и быстрее в реализации.

### 5. Работа с консольным вводом
В Swift ввод реализован через функцию `readLine()`, которая возвращает опциональное значение. Это потребовало дополнительных проверок и обработки пустого ввода. Для удобства был создан универсальный `enum Input<T>` с поддержкой отмены (`q`).  
В Kotlin используется `readlnOrNull()`, которая по умолчанию безопасна и позволяет проще обрабатывать ошибки ввода. В реализации использовалась `sealed class Input<T>`, аналогичная по логике.  
Таким образом, в Kotlin обработка пользовательского ввода оказалась проще и короче.

### 6. Общие выводы
Swift обеспечивает более строгую типобезопасность и хорошо подходит для проектов, где важна надёжность и предсказуемость поведения. Код на Swift немного более подробный, но зато легче отслеживать ошибки на этапе компиляции.  
Kotlin предоставляет более лаконичный синтаксис и гибкие инструменты, что ускоряет разработку. При этом он сохраняет высокий уровень читаемости и понятности.  

По итогам работы можно сказать, что логика приложения выглядит немного чище в Swift благодаря строгой системе типов и протоколам, но реализация на Kotlin оказалась быстрее и компактнее.  
